'use strict';

// ====== Imports & Setup ======
console.log('üîç Iniciando importa√ß√µes...');
require('dotenv').config();
const qrcode = require('qrcode-terminal');
console.log('‚úÖ qrcode-terminal importado');
// ‚¨áÔ∏è Adiciona MessageMedia
const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
console.log('‚úÖ whatsapp-web.js importado');
const axios = require('axios');
console.log('‚úÖ axios importado');

// ====== Env Vars ======
const API_BASE_URL = process.env.API_BASE_URL;
const INTERVAL_MINUTES = Number(process.env.INTERVAL_MINUTES || 5);
const SEND_DELAY_MS = Number(process.env.SEND_DELAY_MS || 10_000); // entre ofertas
const RETRY_SENDS = Number(process.env.RETRY_SENDS || 2);          // tentativas extras por envio
const PER_GROUP_DELAY_MS = Number(process.env.PER_GROUP_DELAY_MS || 2_000); // entre grupos

const RAW_GROUP_IDS = process.env.GROUP_IDS || '';     // "id1,id2,id3"
const RAW_GROUP_NAMES = process.env.GROUP_NAMES || ''; // "Nome A;Nome B;Nome C"

if (!API_BASE_URL) {
  console.error('‚ùå API_BASE_URL ausente no .env');
  process.exit(1);
}

// ====== Helpers de parsing ======
function splitCsv(str) {
  return String(str).split(',').map(s => s.trim()).filter(Boolean);
}
function splitScsv(str) {
  return String(str).split(';').map(s => s.trim()).filter(Boolean);
}

const CONFIG_GROUP_IDS = splitCsv(RAW_GROUP_IDS);
const CONFIG_GROUP_NAMES = splitScsv(RAW_GROUP_NAMES);

// IDs de grupos prontos para uso ap√≥s resolver nomes
let RESOLVED_GROUP_IDS = [];

// ====== Axios Instance ======
const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10_000,
});

// ====== Utils ======
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

function parseNumber(n) {
  if (n == null) return null;
  if (typeof n === 'number') return n;
  if (typeof n === 'string') {
    const normalized = n.replace(/\./g, '').replace(',', '.'); // "1.234,56" -> "1234.56"
    const num = Number(normalized);
    return Number.isFinite(num) ? num : null;
  }
  return null;
}
function formatCurrency(n) {
  const num = parseNumber(n);
  if (num == null) return null;
  return num.toFixed(2).replace('.', ',');
}

// üîÅ TEXTO para legenda (sem URL da imagem)
function formatCaption(product) {
  const parts = [];

  if (product.titulo) {
    parts.push(`*üõçÔ∏è ${product.titulo}üõçÔ∏è* \n`);
  }

  const precoFmt = formatCurrency(product.preco);
  const precoOriginalFmt = formatCurrency(product.preco_original);
  if (precoFmt) {
    // mostra original se existir
    if (precoOriginalFmt) {
      parts.push(`üíµ *Pre√ßo:* R$${precoFmt} - R$${precoOriginalFmt} `);
    } else {
      parts.push(`üíµ *Pre√ßo:* R$ ${precoFmt}`);
    }
  }

  if (product.porcentagem_desconto) {
    parts.push(`üéØ *Desconto:* ${product.porcentagem_desconto}% ~OFF~`);
  }

  
  if (product.rating != null) {
      parts.push(`‚≠ê *Avalia√ß√£o:* ${product.rating}`);
    }
    
    if (product.loja) {
      parts.push(`üè™ *Loja:* ${product.loja}`);
    }

  if (product.free_shipping === true) {
    parts.push(`üöö *Frete:* Gr√°tis \n` );
  } else if (product.free_shipping === false) {
    parts.push(`üöö *Frete:* Pago \n`);
  }

  if (product.url_afiliado) {
    parts.push(`*üîóLink para a compra:*`)
    parts.push(` ${product.url_afiliado}`); // URL pura (sem markdown)
  }

  return parts.join('\n');
}

// ====== Envio b√°sico com retry ======
async function sendMessageWithRetry(client, chatId, content, options = {}, retries = RETRY_SENDS) {
  let attempt = 0;
  while (true) {
    try {
      await client.sendMessage(chatId, content, options);
      return true;
    } catch (err) {
      attempt++;
      console.error(`‚ùå Falha ao enviar para ${chatId} (tentativa ${attempt}):`, err?.message || err);
      if (attempt > retries) return false;
      const backoff = Math.min(15_000, 1_000 * 2 ** attempt);
      console.log(`‚è≥ Aguardando ${backoff}ms antes de tentar novamente...`);
      await sleep(backoff);
    }
  }
}

// ====== Enviar TEXTO para todos os grupos ======
async function sendTextToAllResolvedGroups(text) {
  if (!Array.isArray(RESOLVED_GROUP_IDS) || RESOLVED_GROUP_IDS.length === 0) {
    console.error('‚ùå Nenhum grupo resolvido para envio. Verifique GROUP_IDS/GROUP_NAMES.');
    return { total: 0, successes: 0, results: [] };
  }

  const results = [];
  for (const gid of RESOLVED_GROUP_IDS) {
    console.log(`üöö Enviando TEXTO para grupo ${gid} ...`);
    const ok = await sendMessageWithRetry(client, gid, text, {}, RETRY_SENDS);
    results.push({ groupId: gid, ok });
    if (!ok) console.error(`‚ùå Falha final ao enviar para ${gid}`);
    if (PER_GROUP_DELAY_MS > 0) {
      console.log(`‚è∏Ô∏è Delay entre grupos: ${PER_GROUP_DELAY_MS}ms`);
      await sleep(PER_GROUP_DELAY_MS);
    }
  }
  const successes = results.filter(r => r.ok).length;
  return { total: results.length, successes, results };
}

// ====== Enviar IMAGEM + CAPTION para todos os grupos ======
async function sendMediaToAllResolvedGroups(media, caption) {
  if (!Array.isArray(RESOLVED_GROUP_IDS) || RESOLVED_GROUP_IDS.length === 0) {
    console.error('‚ùå Nenhum grupo resolvido para envio. Verifique GROUP_IDS/GROUP_NAMES.');
    return { total: 0, successes: 0, results: [] };
  }

  const results = [];
  for (const gid of RESOLVED_GROUP_IDS) {
    console.log(`üñºÔ∏è Enviando IMAGEM para grupo ${gid} ...`);
    const ok = await sendMessageWithRetry(client, gid, media, { caption }, RETRY_SENDS);
    results.push({ groupId: gid, ok });
    if (!ok) console.error(`‚ùå Falha final ao enviar para ${gid}`);
    if (PER_GROUP_DELAY_MS > 0) {
      console.log(`‚è∏Ô∏è Delay entre grupos: ${PER_GROUP_DELAY_MS}ms`);
      await sleep(PER_GROUP_DELAY_MS);
    }
  }
  const successes = results.filter(r => r.ok).length;
  return { total: results.length, successes, results };
}

// ====== API Calls ======
async function fetchPendingLinks() {
  try {
    console.log(`[DEBUG] Buscando links em: ${API_BASE_URL}/links/`);
    const { data, status, statusText } = await api.get('/links/', {
      params: { status: 'pendente', limit: 50 },
    });
    console.log(`[DEBUG] Resposta da API:`, status, statusText);
    console.log(`[DEBUG] Dados recebidos:`, data);
    return data?.data || [];
  } catch (error) {
    console.error('‚ùå Erro ao buscar links:', error.message);
    if (error.response) {
      console.error('‚ùå Dados da resposta de erro:', {
        status: error.response.status,
        statusText: error.response.statusText,
        data: error.response.data,
      });
    } else if (error.request) {
      console.error('‚ùå Nenhuma resposta recebida do servidor');
    } else {
      console.error('‚ùå Erro ao configurar a requisi√ß√£o:', error.message);
    }
    return [];
  }
}

async function markAsSent(linkId) {
  try {
    await api.post('/send-whatsapp/', { link_id: linkId });
    return true;
  } catch (error) {
    console.error('‚ùå Erro ao marcar como enviada:', error.message);
    return false;
  }
}

// ====== WhatsApp Client ======
console.log('‚öôÔ∏è  Configurando cliente do WhatsApp...');
const client = new Client({
  authStrategy: new LocalAuth({
    dataPath: './auth',
    clientId: 'client-1',
  }),
  puppeteer: {
    headless: true,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
    ],
  },
});
console.log('‚úÖ Cliente configurado');

client.on('qr', (qr) => {
  console.log('üîë QR Code recebido, gerando...');
  qrcode.generate(qr, { small: true });
  console.log('‚úÖ QR Code gerado com sucesso!');
  console.log('üì± Escaneie o QR Code acima para conectar ao WhatsApp Web');
});

client.on('authenticated', () => {
  console.log('‚úÖ Autenticado no WhatsApp Web');
});

client.on('auth_failure', (msg) => {
  console.error('‚ùå Falha na autentica√ß√£o:', msg);
});

client.on('disconnected', (reason) => {
  console.log('‚ùå Cliente desconectado:', reason);
});

// ====== Envio para m√∫ltiplos grupos ======
async function resolveGroupIdsByNames(names) {
  const chats = await client.getChats();
  const wanted = new Set(names.map(n => n.toLowerCase()));
  const found = [];
  for (const c of chats) {
    if (c.isGroup && c.name && wanted.has(c.name.toLowerCase())) {
      found.push(c.id?._serialized || c.id);
    }
  }
  const missing = names.filter(n =>
    !found.some(id => chats.find(c => c.isGroup && (c.id?._serialized || c.id) === id && c.name?.toLowerCase() === n.toLowerCase()))
  );
  if (missing.length) {
    console.warn('‚ö†Ô∏è Grupos n√£o encontrados por nome:', missing);
  }
  return found;
}

// ====== Fun√ß√£o para download de imagens com tratamento aprimorado ======
async function downloadImage(url, retries = 3, timeout = 300000) {
  const userAgents = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0'
  ];

  const randomUserAgent = userAgents[Math.floor(Math.random() * userAgents.length)];
  
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      console.log(`üîÑ Tentativa ${attempt} de baixar imagem: ${url}`);
      
      const response = await axios({
        method: 'GET',
        url: url,
        responseType: 'arraybuffer',
        timeout: timeout,
        headers: {
          'User-Agent': randomUserAgent,
          'Accept': 'image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8',
          'Accept-Language': 'pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7',
          'Referer': 'https://shopee.com.br/',
          'Sec-Fetch-Dest': 'image',
          'Sec-Fetch-Mode': 'no-cors',
          'Sec-Fetch-Site': 'cross-site'
        },
        validateStatus: status => status >= 200 && status < 400
      });

      if (response.data && response.data.length > 0) {
        const contentType = response.headers['content-type'] || 'image/jpeg';
        const base64 = Buffer.from(response.data, 'binary').toString('base64');
        return new MessageMedia(contentType, base64);
      } else {
        throw new Error('Dados da imagem vazios');
      }
    } catch (error) {
      console.error(`‚ùå Tentativa ${attempt} falhou:`, error.message);
      if (attempt === retries) {
        console.error('‚ùå Todas as tentativas de download falharam');
        return null;
      }
      // Espera exponencial entre tentativas (1s, 2s, 4s, etc.)
      await sleep(1000 * Math.pow(2, attempt - 1));
    }
  }
  return null;
}

// ====== Processing (mutex + cache de IDs) ======
let isProcessing = false;
const sentIds = new Set();

async function processPendingLinks() {
  console.log('üîé Buscando ofertas pendentes...');
  const links = await fetchPendingLinks();

  if (!Array.isArray(links) || links.length === 0) {
    console.log('üü© Nenhuma oferta pendente encontrada.');
    return;
  }

  console.log(`üü® Encontradas ${links.length} ofertas pendentes.`);

  for (const link of links) {
    const id = link?.id;
    if (!id) {
      console.warn('‚ö†Ô∏è Item sem ID. Pulando.', link);
      continue;
    }
    if (sentIds.has(id)) {
      console.log(`‚Ü©Ô∏è J√° processado nesta sess√£o: ${id}`);
      continue;
    }

    try {
      const caption = formatCaption(link);

      if (link.imagem_url) {
        try {
          // Tenta baixar a imagem com nosso m√©todo personalizado
          console.log(`üñºÔ∏è Baixando imagem para oferta ${id}...`);
          const media = await downloadImage(link.imagem_url);
          
          if (media) {
            console.log(`‚úÖ Imagem baixada com sucesso para oferta ${id}`);
            const batch = await sendMediaToAllResolvedGroups(media, caption);
            
            if (batch.successes > 0) {
              console.log(`‚úÖ Oferta ${id} (com imagem) enviada para ${batch.successes}/${batch.total} grupo(s).`);
              const marked = await markAsSent(id);
              if (!marked) console.warn(`‚ö†Ô∏è Falha ao marcar ${id} como enviada na API.`);
              sentIds.add(id);
            } else {
              console.error(`‚ùå Falha ao enviar oferta ${id} para os grupos.`);
              continue; // Pula para a pr√≥xima oferta
            }
          } else {
            console.error(`‚ùå N√£o foi poss√≠vel baixar a imagem da oferta ${id}. Pulando para a pr√≥xima oferta.`);
            continue; // Pula para a pr√≥xima oferta
          }
        } catch (imgErr) {
          console.error(`‚ö†Ô∏è Erro ao processar imagem da oferta ${id}:`, imgErr.message);
          console.error(`‚ùå Pulando oferta ${id} devido ao erro na imagem.`);
          continue; // Pula para a pr√≥xima oferta em caso de erro
        }
      } else {
        // Sem imagem: envia apenas texto
        console.log(`üìù Enviando apenas texto para oferta ${id}`);
        const batch = await sendTextToAllResolvedGroups(caption);
        
        if (batch.successes > 0) {
          console.log(`‚úÖ Oferta ${id} enviada (sem imagem) para ${batch.successes}/${batch.total} grupo(s).`);
          const marked = await markAsSent(id);
          if (!marked) console.warn(`‚ö†Ô∏è Falha ao marcar ${id} como enviada na API.`);
          sentIds.add(id);
        } else {
          console.error(`‚ùå Falha ao enviar oferta ${id} para os grupos.`);
        }
      }

      console.log(`‚è∏Ô∏è Aguardando ${SEND_DELAY_MS}ms antes da pr√≥xima oferta...`);
      await sleep(SEND_DELAY_MS);
      
    } catch (error) {
      console.error(`‚ùå Erro ao processar oferta ${id}:`, error.message);
      await sleep(5000); // Espera 5 segundos antes de continuar
    }
  }
}

async function safeProcessPendingLinks() {
  if (isProcessing) {
    console.log('‚è≥ J√° existe um processamento em andamento. Pulando esta rodada.');
    return;
  }
  isProcessing = true;
  try {
    await processPendingLinks();
  } finally {
    isProcessing = false;
  }
}

// ====== Ready Handler √önico ======
client.on('ready', async () => {
  console.log('üöÄ Bot pronto para uso!');
  console.log('üì± N√∫mero do bot:', client.info?.wid?.user);

  try {
    const ids = new Set(CONFIG_GROUP_IDS);

    if (CONFIG_GROUP_NAMES.length) {
      console.log('üîé Resolvendo nomes de grupos para IDs...');
      const foundIds = await resolveGroupIdsByNames(CONFIG_GROUP_NAMES);
      for (const id of foundIds) ids.add(id);
    }

    RESOLVED_GROUP_IDS = Array.from(ids);
    if (!RESOLVED_GROUP_IDS.length) {
      console.error('‚ùå Nenhum grupo dispon√≠vel. Defina GROUP_IDS ou GROUP_NAMES no .env');
      process.exit(1);
    }

    console.log('üìã Grupos configurados:', RESOLVED_GROUP_IDS);

    console.log('üîÑ Iniciando processamento de ofertas pendentes...');
    await safeProcessPendingLinks();
    console.log('‚úÖ Processamento inicial conclu√≠do!');
  } catch (error) {
    console.error('‚ùå Erro no processamento inicial:', error);
  }

  console.log(`‚è±Ô∏è Pr√≥xima verifica√ß√£o em ${INTERVAL_MINUTES} minuto(s)...`);
  setInterval(safeProcessPendingLinks, INTERVAL_MINUTES * 60 * 1000);
});

// ====== Start & Graceful Shutdown ======
client.initialize();

process.on('SIGINT', async () => {
  console.log('üßπ Encerrando (SIGINT)...');
  try { await client.destroy(); } catch {}
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('üßπ Encerrando (SIGTERM)...');
  try { await client.destroy(); } catch {}
  process.exit(0);
});

process.on('unhandledRejection', (reason) => {
  console.error('üí• Erro n√£o tratado (Promise):', reason);
});

process.on('uncaughtException', (err) => {
  console.error('üí• Exce√ß√£o n√£o capturada:', err);
});
